package nl.pim16aap2.commandparser.command;

import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import nl.pim16aap2.commandparser.argument.Argument;
import nl.pim16aap2.commandparser.exception.CommandNotFoundException;
import nl.pim16aap2.commandparser.exception.IllegalValueException;
import nl.pim16aap2.commandparser.renderer.ArgumentRenderer;
import nl.pim16aap2.commandparser.renderer.ColorScheme;
import nl.pim16aap2.commandparser.renderer.TextComponent;
import nl.pim16aap2.commandparser.renderer.TextType;
import nl.pim16aap2.commandparser.util.Pair;
import nl.pim16aap2.commandparser.util.Util;
import org.jetbrains.annotations.Nullable;

import java.util.Optional;
import java.util.OptionalInt;

/**
 * Represents the default {@link IHelpCommand}.
 *
 * @author Pim
 */
@Builder
@Getter
public class DefaultHelpCommand implements IHelpCommand
{
    // TODO: Make this configurable
    private static final String COMMAND_PREFIX = "/";

    /**
     * The {@link ColorScheme} to use for the help text generated by this {@link IHelpCommand}
     */
    private final @NonNull ColorScheme colorScheme;

    /**
     * The number of subcommands to display per page. Default = 5.
     */
    @Builder.Default
    private int pageSize = 5;

    /**
     * The number of subcommands on the first page. Default = 1.
     */
    @Builder.Default
    private int firstPageSize = 1;

    /**
     * Whether or not to display the header of the command on the first page. Default = true.
     */
    @Builder.Default
    private boolean displayHeader = true;

    /**
     * The string to prepend before every summary. Default = "  ".
     */
    @Builder.Default
    private String summaryIndent = "  ";

    /**
     * Whether or not to display the arguments of each command on the list page.
     */
    @Builder.Default
    private boolean displayArgumentsForSimple = false;

    protected @NonNull ArgumentRenderer argumentRenderer;

    public DefaultHelpCommand(final @NonNull ColorScheme colorScheme, final int pageSize, final int firstPageSize,
                              final boolean displayHeader, final @NonNull String summaryIndent,
                              final boolean displayArgumentsForSimple,
                              final @Nullable ArgumentRenderer argumentRenderer)
    {
        this.colorScheme = colorScheme;
        this.pageSize = pageSize;
        this.firstPageSize = firstPageSize;
        this.displayHeader = displayHeader;
        this.displayArgumentsForSimple = displayArgumentsForSimple;
        this.argumentRenderer = argumentRenderer == null ? new ArgumentRenderer(colorScheme) : argumentRenderer;
        this.summaryIndent = summaryIndent;
    }

    protected final int getCommandCount(final @NonNull Command command)
    {
        // TODO: Store this in the Command itself. Just do it on creation, then ensure that
        //       a) They cannot be modified after construction, or
        //       b) They recalculate it when they are modified.
        int count = command.isHidden() ? 0 : 1;
        for (final Command subCommand : command.getSubCommands())
            count += getCommandCount(subCommand);
        return count;
    }

    protected int getPageCount(final @NonNull Command command)
    {
        final int commandCount = getCommandCount(command);

        // Get the number of pages that can be filled using the provided number of commands
        // and the provided page size, excluding the number of commands put on the first page.
        return (int) Math.ceil((commandCount - firstPageSize) / (float) pageSize);
    }

    protected void renderPageCount(final @NonNull TextComponent textComponent, final int page, final int pageCount)
    {
        // TODO: Allow starting either at 0 or at 1.
        textComponent.add(String.format("------- Page (%2d / %2d) -------\n", page, pageCount));
    }

    @Override
    public @NonNull TextComponent render(final @NonNull Command command, final int page)
        throws IllegalValueException
    {
        final int pageCount = getPageCount(command);
        if (page > pageCount)
            throw new IllegalValueException(command, Integer.toString(page));

        TextComponent textComponent = new TextComponent(colorScheme);
        renderPageCount(textComponent, page, pageCount);
        if (page == 0)
            return renderFirstPage(textComponent, command);

        final int skip = firstPageSize + (page - 1) * pageSize;
        renderCommands(textComponent, getBaseSuperCommand(command), command, this.pageSize, skip);

        return textComponent;
    }

    @Override
    public @NonNull TextComponent render(final @NonNull Command command, final @NonNull String val)
        throws IllegalValueException, CommandNotFoundException
    {
        final OptionalInt pageOpt = Util.parseInt(val);
        if (pageOpt.isPresent())
            return render(command, pageOpt.getAsInt());

//        final @NonNull Optional<Command> subCommand = command.getSubCommand(val);
        final @NonNull Optional<Command> subCommand = command.getCommandManager().getCommand(val);
        if (!subCommand.isPresent())
            throw new CommandNotFoundException(val);

        return render(subCommand.get(), 0);
    }

    @Override
    public @NonNull TextComponent renderLongCommand(final @NonNull Command command)
    {
        final TextComponent textComponent = new TextComponent(colorScheme);
//        if (displayHeader && !command.getHeader().equals(""))
//            textComponent.add(command.getHeader(), TextType.HEADER).add("\n");
        final TextComponent basesuper = getBaseSuperCommand(command);
        renderCommand(textComponent, command, getBaseSuperCommand(command));
        renderArgumentsLong(textComponent, command);
        return textComponent;
    }

    /**
     * Recursively constructs the {@link TextComponent} containing the all super {@link Command}s of a {@link Command}.
     * <p>
     * Note that the {@link Command} that is provided inside the optional is also included if possible, so if this is
     * not desired, use this method with {@link Command#getSuperCommand()}.
     *
     * @param command The {@link Optional} {@link Command} whose super commands to add to the text. If it has no super
     *                commands (or isn't {{@link Optional#isPresent()}}), it will only append {@link #COMMAND_PREFIX}
     *                and the name of this command itself (if possible).
     * @return The {@link TextComponent} with all the super {@link Command}s of the provided {@link Command}.
     */
    protected @NonNull TextComponent getBaseSuperCommand(final @NonNull Optional<Command> command)
    {
        // Base case
        if (!command.isPresent())
            return new TextComponent(colorScheme).add(COMMAND_PREFIX, TextType.COMMAND);

        return getBaseSuperCommand(command.get().getSuperCommand()).add(command.get().getName()).add(" ");
    }

    /**
     * Recursively constructs the {@link TextComponent} containing the all super {@link Command}s of a {@link Command}.
     * <p>
     * Note that the {@link Command} that is provided will not be included.
     *
     * @param command The {@link Command} whose super commands to add to the text. If it has no super commands, it will
     *                only append {@link #COMMAND_PREFIX}.
     * @return The {@link TextComponent} with all the super {@link Command}s of the provided {@link Command}.
     */
    protected @NonNull TextComponent getBaseSuperCommand(final @NonNull Command command)
    {
        return getBaseSuperCommand(command.getSuperCommand());
    }

    protected @NonNull TextComponent renderFirstPage(final @NonNull TextComponent textComponent,
                                                     final @NonNull Command command)
    {
        if (displayHeader && !command.getHeader().equals(""))
            textComponent.add(command.getHeader(), TextType.HEADER).add("\n");

        renderCommands(textComponent, getBaseSuperCommand(command), command, this.firstPageSize, 0);

        return textComponent;
    }

    /**
     * Recursively renders the given command as well as all its subcommands.
     *
     * @param textComponent The {@link TextComponent} to append the help to.
     * @param superCommands A {@link TextComponent} with all the appended super commands of the current command. This
     *                      will be prepended to the command.
     * @param command       The {@link Command} and {@link Command#getSubCommands()} to render (recursively).
     * @param count         The number of {@link Command}s to render.
     * @return The number of commands that were added to the {@link TextComponent}.
     */
    protected @NonNull Pair<Integer, Integer> renderCommands(final @NonNull TextComponent textComponent,
                                                             final @NonNull TextComponent superCommands,
                                                             final @NonNull Command command, final int count,
                                                             final int skip)
    {
        // Added contains the number of commands added to the text.
        int added = 0;
        if (count < 1)
            return new Pair<>(added, 0);

        // Skipped contains the number of commands that were not rendered because they fell into the skipped category.
        int skipped = 0;

        // Don't render hidden commands, because they're... Well... hidden.
        if (!command.isHidden())
        {
            // Only render the command if it doesn't have to be skipped.
            if (skip > skipped)
                ++skipped;
            else
            {
                renderCommand(textComponent, command, superCommands);
                ++added;
            }
        }

        if (added == count)
            return new Pair<>(added, skipped);

        // The current command has to be appended to the super commands, because the
        // current command is the super command of all its sub commands (by definition).
        final TextComponent newSuperCommands =
            new TextComponent(superCommands).add(command.getName(), TextType.COMMAND).add(" ");

        for (final Command subCommand : command.getSubCommands())
        {
            final @NonNull Pair<Integer, Integer> renderResult =
                renderCommands(textComponent, newSuperCommands, subCommand, count - added, skip - skipped);

            added += renderResult.first;
            skipped += renderResult.second;

            if (added >= count)
                break;
        }
        return new Pair<>(added, skipped);
    }

    /**
     * Renders a command and appends it to the provided {@link TextComponent}.
     *
     * @param textComponent The {@link TextComponent} to append the rendered command to.
     * @param command       The {@link Command} to render. Note that this method does not care about {@link
     *                      Command#isHidden()}.
     * @param superCommands A {@link TextComponent} with all the appended super commands of the current command. This
     *                      will be prepended to the command.
     */
    protected void renderCommand(final @NonNull TextComponent textComponent, final @NonNull Command command,
                                 final @NonNull TextComponent superCommands)
    {
        textComponent.add(superCommands).add(command.getName(), TextType.COMMAND);
        renderArgumentsShort(textComponent, command);

        if (!command.getSummary().equals(""))
            textComponent.add(summaryIndent).add(command.getSummary() + "\n", TextType.SUMMARY);
    }

    protected void renderArgumentsShort(final @NonNull TextComponent textComponent, final @NonNull Command command)
    {
        // TODO: This should not be hardcoded like this.
        for (final Argument<?> argument : command.getRequiredArguments().values())
            textComponent.add(" ").add(argumentRenderer.render(argument));

        for (final Argument<?> argument : command.getOptionalArguments().values())
            textComponent.add(" ").add(argumentRenderer.render(argument));

        for (final Argument<?> argument : command.getRepeatableArguments().values())
            textComponent.add(" ").add(argumentRenderer.render(argument));
        textComponent.add("\n");
    }

    protected void renderArgumentsLong(final @NonNull TextComponent textComponent, final @NonNull Command command)
    {
        // TODO: This should not be hardcoded like this.
        for (final Argument<?> argument : command.getRequiredArguments().values())
            textComponent.add(argumentRenderer.renderLong(argument, summaryIndent));

        for (final Argument<?> argument : command.getOptionalArguments().values())
            textComponent.add(argumentRenderer.renderLong(argument, summaryIndent));

        for (final Argument<?> argument : command.getRepeatableArguments().values())
            textComponent.add(argumentRenderer.renderLong(argument, summaryIndent));
        textComponent.add("\n");
    }
}
